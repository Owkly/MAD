# 1 Visualisation et prétraitement des données

```{r}
getwd()
library(dplyr) 
library(stringr)
```

## Chargement des données et visualisation

```{r}
path = file.path(getwd(), "original_data/job_postings.csv")
data <- read.csv(path, header = TRUE)
names(data)
```
```{r}
str(data)
```
```{r}
head(data)
```

## Filtrage par type de travail

```{r}
# type d'emploi possible
print(paste(unique(data$work_type)))
```
```{r}
initial_rows <- nrow(data)
# Conservation des emplois à temps plein
data1 <- data[data$work_type == "FULL_TIME", ]
filtered_rows <- nrow(data1)
print(paste("Lignes avant le filtrage :", initial_rows))
print(paste("Lignes retirées :", initial_rows - filtered_rows))
print(paste("Lignes après filtrage par type de travail (FULL_TIME) :", filtered_rows))
```

## Filtrage par période de paie

```{r}
# Période de paie possible
print(paste(unique(data$pay_period)))
```

```{r}
initial_rows <- nrow(data1)
# Conservation des données avec une période de paie mensuelle ou annuelle
# D'ailleurs il y'avait beaucoup de données qui était vide "", on a essayé de les remplacer par "MONTHLY" mais on a vu que dans le filtre juste après il les retirés dans tous les cas

# data1$pay_period[data1$pay_period == ""] <- "MONTHLY"
data2 <- data1[data1$pay_period %in% c("MONTHLY","YEARLY"), ]
filtered_rows <- nrow(data2)
print(paste("Lignes avant le filtrage :", initial_rows))
print(paste("Lignes après filtrage par période de paie (MONTHLY, YEARLY) :", filtered_rows))
print(paste("Lignes retirées :", initial_rows - filtered_rows))
```

## Filtrage par présence de salaire

```{r}
initial_rows <- nrow(data2)
# On conserve uniquement les lignes où au moins une information sur le salaire est présente
# Cela a retiré beaucoup de données mais c'était nécessaire
data3 <- data2[!is.na(data2$min_salary) | !is.na(data2$med_salary) | !is.na(data2$max_salary), ]
filtered_rows <- nrow(data3)
print(paste("Lignes avant le filtrage :", initial_rows))
print(paste("Lignes après filtrage par présence de salaire :", filtered_rows))
print(paste("Lignes retirées :", initial_rows - filtered_rows))
```
## Simplification et conversion des salaires

```{r}
# on garde en priorité la médiane (donné ou calculé), sinon le max, puis le min
simplify_salary <- function(med, max, min) {
  if (!is.na(med)) {
    return(med)
  } else if (!is.na(max) & !is.na(min)) {
    return((max + min) / 2)
  } else if (!is.na(max)) {
    return(max)
  } else if (!is.na(min)) {
    return(min)
  } else {
    return(NA)
  }
}

# Conversion du salaire mensuel en salaire annuel
convert_salary <- function(salary, period) {
  if (period == "MONTHLY") {
    return(salary * 12)
  } else {
    return(salary)
  }
}

# Application des fonction sur le jeu de données et mes place dans une nouvelle colonne salary
data3$salary <- mapply(simplify_salary, data3$med_salary, data3$max_salary, data3$min_salary)
data3$salary <- mapply(convert_salary, data3$salary, data3$pay_period)

# Suppression des colonnes des salaire max, min et med
data4 <- select(data3, -c(med_salary, max_salary, min_salary, pay_period))
```

```{r}
ncol(data)
ncol(data4)
```

## Suppression des autres colonnes non nécessaire
```{r}
unique(data4$currency)
unique(data4$compensation_type)
unique(data4$work_type)
unique(data4$formatted_work_type)
```
```{r}
data5 <- select(data4, -c(description, skills_desc, job_posting_url, application_url,posting_domain, currency, compensation_type, formatted_work_type, work_type))
```

## Remplacement des données NA

```{r}
# applies : le nombre de personne qui ont postulé, si c'est NA on considère que personne n'a postulé
data5$applies[is.na(data5$applies)] <- 0
# remote_allowed : autorise le travail à distance, si c'est NA on considère que c'est pas autorisé dans le contrat
data5$remote_allowed[is.na(data5$remote_allowed)] <- 0
# views : le nombre de vues, si c'est NA on considère qu'il y a 0 vues
data5$views[is.na(data5$views)] <- 0
# formatted_experience_level : spécifie le niveau d'expérience requis nécessaire pour postuler au poste, si ce n'est pas indiqué on considère que tout le monde peut le faire
data$formatted_experience_level[data$formatted_experience_level == ""] <- "Entry level"
```


```{r}
data5
```


## Traitement des données temporelles

```{r}
data6 <- data5
# Convertir les temps de millisecondes à des dates lisibles
data6$original_listed_time <- as.POSIXct(data5$original_listed_time / 1000, origin = "1970-01-01", tz = "UTC")
data6$expiry <- as.POSIXct(data5$expiry / 1000, origin = "1970-01-01", tz = "UTC")
data6$closed_time <- as.POSIXct(data5$closed_time / 1000, origin = "1970-01-01", tz = "UTC")
data6$listed_time <- as.POSIXct(data5$listed_time / 1000, origin = "1970-01-01", tz = "UTC")
```


```{r}
# Vérifier le nombre de NA dans chaque sur les temps
# original_listed_time : indique le moment où l'offre d'emploi a été initialement publiée ou listée pour la première fois
# expiry : La date à laquelle l'annonce de l'emploi expire et n'acceptera plus de candidatures.
# closed_time : Le moment où l'annonce de l'emploi a été fermée (peut-être avant l'expiration si le poste a été pourvu).
# listed_time : indique la date de la dernière mise à jour de l'annonce

na_original_listed_time <- sum(is.na(data6$original_listed_time))
na_expiry <- sum(is.na(data6$expiry))
na_closed_time <- sum(is.na(data6$closed_time))
na_listed_time <- sum(is.na(data6$listed_time))

print(paste("NA in original_listed_time:", na_original_listed_time))
print(paste("NA in expiry:", na_expiry))
print(paste("NA in closed_time:", na_closed_time))
print(paste("NA in listed_time:", na_listed_time))
```
closed_time contient des NA
```{r}
# On remplace les NA par le 1er janvier 2030
data6$closed_time[is.na(data6$closed_time)] <- as.numeric(as.POSIXct("2030-01-01", tz = "GMT"))
head(data6)
```


# Conversion des int en booléens
conversion des variables (booléens mais qui était représenter en int) en booléens
```{r}
data7 <- data6
data7$sponsored <- as.logical(data7$sponsored)
data7$remote_allowed <- as.logical(data7$remote_allowed)
str(data7)
```

# Catégorisation des lieux

```{r}
data8 <- data7 %>%
  mutate(geographic_scope = case_when(
    # 1
    str_detect(location, "CT|ME|MA|NH|RI|VT") ~ "Boston",
    str_detect(location, "NY|NJ|PR|VI") ~ "New York City",
    str_detect(location, "DE|DC|MD|PA|VA|WV") ~ "Philadelphia",
    str_detect(location, "AL|FL|GA|KY|MS|NC|SC|TN") ~ "Atlanta",
    str_detect(location, "IL|IN|MN|MI|OH|WI") ~ "Chicago",
    str_detect(location, "AR|LA|NM|OK|TX") ~ "Dallas",
    str_detect(location, "IA|KS|MO|NE") ~ "Kansas City",
    str_detect(location, "CO|MT|ND|SD|UT|WY") ~ "Denver",
    str_detect(location, "AZ|CA|HI|NV|GU|AS") ~ "San Francisco",
    str_detect(location, "AK|ID|OR|WA") ~ "Seattle",
    grepl("United States", location, ignore.case = TRUE) ~ "National",
    
    
    #2
    str_detect(location, "Connecticut|Maine|Massachusetts|New Hampshire|Rhode Island|Vermont") ~ "Boston",
    str_detect(location, "New York|New Jersey|Puerto Rico|Virgin Islands") ~ "New York City",
    str_detect(location, "Delaware|District of Columbia|Maryland|Pennsylvania|Virginia|West Virginia") ~ "Philadelphia",
    str_detect(location, "Alabama|Florida|Georgia|Kentucky|Mississippi|North Carolina|South Carolina|Tennessee") ~ "Atlanta",
    str_detect(location, "Illinois|Indiana|Minnesota|Michigan|Ohio|Wisconsin") ~ "Chicago",
    str_detect(location, "Arkansas|Louisiana|New Mexico|Oklahoma|Texas") ~ "Dallas",
    str_detect(location, "Iowa|Kansas|Missouri|Nebraska") ~ "Kansas City",
    str_detect(location, "Colorado|Montana|North Dakota|South Dakota|Utah|Wyoming") ~ "Denver",
    str_detect(location, "Arizona|California|Hawaii|Nevada|Guam|American Samoa") ~ "San Francisco",
    str_detect(location, "Alaska|Idaho|Oregon|Washington") ~ "Seattle",
    
    
    # 3
    str_detect(location, "Boston") ~ "Boston",
    str_detect(location, "New York City") ~ "New York City",
    str_detect(location, "Philadelphia") ~ "Philadelphia",
    str_detect(location, "Atlanta") ~ "Atlanta",
    str_detect(location, "Chicago") ~ "Chicago",
    str_detect(location, "Dallas") ~ "Dallas",
    str_detect(location, "Kansas City") ~ "Kansas City",
    str_detect(location, "Denver") ~ "Denver",
    str_detect(location, "San Francisco") ~ "San Francisco",
    str_detect(location, "Seattle") ~ "Seattle",


    # 4
    str_detect(location, "Bangor") ~ "Boston",
    str_detect(location, "Hartford|Scranton|Buffalo-Niagara|Erie|Buffalo") ~ "New York City",
    str_detect(location, "Harrisburg|Richmond") ~ "Philadelphia",
    str_detect(location, "Chattanooga|Macon|Nashville|Asheville|Raleigh-Durham|New Orleans|Miami|Tampa|Jacksonville|Orlando|Pensacola|Charlotte|Greensboro|Memphis|Knoxville|Mobile|Bowling Green|Johnson City|Palm Bay-Melbourne-Titusville|Crestview-Fort Walton Beach-Destin|Tallahassee") ~ "Atlanta",
    str_detect(location, "Detroit|Cincinnati|Milwaukee|Grand Rapids|Minneapolis|Pittsburgh|Cleveland|Fargo|Urbana-Champaign|Bloomington|Louisville") ~ "Chicago",
    str_detect(location, "McAllen|Houston|Beaumont") ~ "Dallas",
    str_detect(location, "Omaha|Des Moines|St. Louis|Sioux Falls") ~ "Kansas City",
    str_detect(location, "Reno|Pueblo|Fort Collins|Salt Lake City") ~ "Denver",
    str_detect(location, "Sacramento|Yuma|Albuquerque|Los Angeles|San Diego|Eugene-Springfield|Phoenix|Las Vegas") ~ "San Francisco",

    
    # 5
    TRUE ~ "Other"
  ))

sum(table(data8$geographic_scope))
table(data8$geographic_scope)
```

```{r}
  # Vérifie s'il y a toujours des location qui n'ont pas été catégoriser
  other <- filter(data8, geographic_scope == "Other")
  unique(other$location)
  
  # suppression de la colonne location
  data8 <- select(data8, -location)
  head(data8)
```


# Enregistrement du dataframe traité dans un fichier CSV
```{r}
write.csv(data8, "job_processed.csv", row.names = FALSE)
```

